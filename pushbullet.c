#include <uwsgi.h>
#include <curl/curl.h>
#include <jansson.h>

extern struct uwsgi_server uwsgi;

#define PUSHBULLET_PUSH_URL "https://api.pushbullet.com/v2/pushes"

struct pushbullet_config {
    // Pushbullet API token
    char *token;

    // Pushbullet targets
    // Only one can be specified
    char *device_iden;
    char *email;
    char *channel_tag;
    char *client_iden;

    // Optional parameters
    char *source_device_iden;

    // Push details
    char *title;
    char *body;
    char *url;

    // Autogenerated parameters
    const char *type;

    // Other configuration options
    char *ssl_no_verify;
    char *timeout;
};

#define pkv(x) #x, &pbc->x
static int pushbullet_config_do(char *arg, struct pushbullet_config *pbc) {
    const char* type_note = "note";
    const char* type_link = "url";

    const char* default_title = "uWSGI Alert!";

    memset(pbc, 0, sizeof(struct pushbullet_config));

    if (uwsgi_kvlist_parse(arg, strlen(arg), ',', '=',
                pkv(token),
                pkv(device_iden),
                pkv(email),
                pkv(channel_tag),
                pkv(client_iden),
                pkv(source_device_iden),
                pkv(title),
                pkv(body),
                pkv(url),
                pkv(ssl_no_verify),
                pkv(timeout),
                NULL)) {
        uwsgi_log("[uwsgi-pushbullet] unable to parse specified Pushbullet options\n");
        return -1;
    }

    if (!pbc->token) {
        uwsgi_log("[uwsgi-pushbullet] you need to specify a Pushbullet API token\n");
        return -1;
    }

    if (pbc->url) {
        pbc->type = type_link;
    } else {
        pbc->type = type_note;
    }

    if (!pbc->title) {
        pbc->title = uwsgi_str((char *)default_title);
    }

    return 0;
}

static void pushbullet_free(struct pushbullet_config *pbc) {
    if (pbc->token) free(pbc->token);
    if (pbc->device_iden) free(pbc->device_iden);
    if (pbc->email) free(pbc->email);
    if (pbc->channel_tag) free(pbc->channel_tag);
    if (pbc->client_iden) free(pbc->client_iden);
    if (pbc->source_device_iden) free(pbc->source_device_iden);
    if (pbc->title) free(pbc->title);
    if (pbc->body) free(pbc->body);
    if (pbc->url) free(pbc->url);
    if (pbc->ssl_no_verify) free(pbc->ssl_no_verify);
    if (pbc->timeout) free(pbc->timeout);
}

static json_t *build_json(struct pushbullet_config *pbc, char* body) {
    json_t *j = json_object();

    if (json_object_set_new(j, "type", json_string(pbc->type))) goto error;
    if (json_object_set_new(j, "title", json_string(pbc->title))) goto error;

    if (body) {
        if (json_object_set_new(j, "body", json_string(body))) goto error;
    } else {
        if (json_object_set_new(j, "body", json_string(pbc->body))) goto error;
    }

    if (pbc->source_device_iden) {
        if (json_object_set_new(j, "source_device_iden", json_string(pbc->source_device_iden))) goto error;
    }

    // Only a device field can be set!
    if (pbc->device_iden) {
        if (json_object_set_new(j, "device_iden", json_string(pbc->device_iden))) goto error;
    } else if (pbc->email) {
        if (json_object_set_new(j, "email", json_string(pbc->email))) goto error;
    } else if (pbc->channel_tag) {
        if (json_object_set_new(j, "channel_tag", json_string(pbc->channel_tag))) goto error;
    } else if (pbc->client_iden) {
        if (json_object_set_new(j, "client_iden", json_string(pbc->client_iden))) goto error;
    }

    return j;

error:
    uwsgi_log("[uwsgi-pushbullet] error while creating Pushbullet JSON\n");
    return NULL;
}

// Callback to ignore response from server
size_t write_data(void *buffer, size_t size, size_t nmemb, void *userp) {
   return size * nmemb;
}

static int pushbullet_request(struct pushbullet_config *pbc, char* body) {
    int ret = 0;
    char *j_string = NULL;

    struct curl_slist *headerlist = NULL;
    static const char *authorization_pre = "Authorization: Bearer ";
    static const char *content_type = "Content-Type: application/json";

    CURL *curl = curl_easy_init();
    if (!curl) {
        uwsgi_log("[uwsgi-pushbullet] curl_easy_init error\n");
        ret = -1;
        goto cleanup;
    }

    // Prepare the header
    headerlist = curl_slist_append(headerlist, content_type);

    char *authorization = uwsgi_concat2((char *)authorization_pre, pbc->token);
    headerlist = curl_slist_append(headerlist, authorization);
    free(authorization);

    // Prepare the body
    json_t *j;
    if (!(j = build_json(pbc, body))) {
        ret = -1;
        goto cleanup;
    }

    j_string = json_dumps(j, 0);
    json_decref(j);

    int timeout = uwsgi.socket_timeout;
    if (pbc->timeout) {
        char *end;
        int t = strtol(pbc->timeout, &end, 10);
        if (!*end) {
            timeout = t;
        }
    }
    char *url = PUSHBULLET_PUSH_URL;

    curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);
    curl_easy_setopt(curl, CURLOPT_URL, url);

    if (pbc->ssl_no_verify) {
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
    }

    // CURLOPT_POSTFIELDS sets the request method to POST
    // And the payload to the json string
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, j_string);

    // Set the headers after the HTTP method to overwrite Content Type
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);

    // Set a custom writer to avoid SDOUT
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);

    CURLcode res = curl_easy_perform(curl);
    long http_code = 0;
    curl_easy_getinfo (curl, CURLINFO_RESPONSE_CODE, &http_code);

    if (res != CURLE_OK) {
        uwsgi_log("[uwsgi-pushbullet] libcurl error: %s\n", curl_easy_strerror(res));
        ret = -1;
        goto cleanup;
    } else if (http_code != 200){
        uwsgi_log("[uwsgi-pushbullet] Pushbullet returned wrong http status code: %d\n", http_code);
        ret = -1;
        goto cleanup;
    }

cleanup:
    curl_easy_cleanup(curl);
    curl_slist_free_all(headerlist);

    if (j_string) {
        free(j_string);
    }

    return ret;
}

static int pushbullet_hook(char *arg) {
    int ret = -1;
    struct pushbullet_config pbc;

    if (pushbullet_config_do(arg, &pbc)) {
        goto clear;
    }

    if (!pbc.body) {
        uwsgi_log("[uwsgi-pushbullet] you need to specify the push body for hooks\n");
        goto clear;
    }

    ret = pushbullet_request(&pbc, NULL);

clear:
    pushbullet_free(&pbc);
    return ret;
}

static void pushbullet_alarm_func(struct uwsgi_alarm_instance *uai, char *msg, size_t len) {
    struct pushbullet_config *pbc = (struct pushbullet_config *)uai->data_ptr;

    char *tmp = uwsgi_concat2n(msg, len, "", 0);
    pushbullet_request(pbc, tmp);
    free(tmp);
}

static void pushbullet_alarm_init(struct uwsgi_alarm_instance *uai) {
    struct pushbullet_config *pbc = uwsgi_calloc(sizeof(struct pushbullet_config));

    if (pushbullet_config_do(uai->arg, pbc)) {
        exit(1);
    }

    uai->data_ptr = pbc;
}

static void pushbullet_register() {
    uwsgi_register_hook("pushbullet", pushbullet_hook);
    uwsgi_register_alarm("pushbullet", pushbullet_alarm_init, pushbullet_alarm_func);
}

struct uwsgi_plugin pushbullet_plugin = {
    .name = "pushbullet",
    .on_load = pushbullet_register,
};
